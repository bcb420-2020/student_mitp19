---
title: "BCB420- A2"
author: "Mit Patel"
output:
  html_document:
    df_print: paged
---
# Results from A1
We will nest our A1 document in this notebook to continue our analysis.  
```{r nest a1, message=FALSE, warning=FALSE, child='a1.Rmd', include=FALSE, results='hide'}

```
---

# A2 starts here
#### Data Overview: 
The dataset being used in this analysis is based on what is published in [1].
#### Analysis Objectives: 

First we will install the necessary packages: 
```{r setup a2, message=FALSE, results='hide'}
if (!requireNamespace("BiocManager", quietly = TRUE)) {
   install.packages(pkgs = c("BiocManager"),
           repos = "http://cran.rstudio.org",
           dependencies = TRUE,
           quiet = TRUE) 
}
if (!requireNamespace("circlize", quietly = TRUE)) {
   install.packages(pkgs = c("circlize"),
           repos = "http://cran.rstudio.org",
           dependencies = TRUE,
           quiet = TRUE) 
}

if (!requireNamespace("gprofiler2", quietly = TRUE)) {
   install.packages(pkgs = c("circlize"),
           repos = "http://cran.rstudio.org",
           dependencies = TRUE,
           quiet = TRUE) 
}

BiocManager::install("ComplexHeatmap")
BiocManager::install("limma")
BiocManager::install("GOstats")

library(Biobase)
library(circlize)
library(limma)
library(grid)
library(gprofiler2)

normalized_count_data <- normalized_counts_annot_filtered
```
First we will setup or data variables:
```{r}

intron_cols <- grep("Intron.*|ensembl_gene_id|hgnc_symbol*", names(normalized_count_data), value = TRUE)
exon_cols <- grep("Exon*|ensembl_gene_id|hgnc_symbol", names(normalized_count_data), value = TRUE)
normalized_count_data_introns <- normalized_count_data[ , intron_cols]
normalized_count_data_exons <- normalized_count_data[ , exon_cols]

heatmap_matrix <- normalized_count_data[ ,3:ncol(normalized_count_data)]
rownames(heatmap_matrix) <- normalized_count_data$ensemble_gene_id
colnames <- colnames(normalized_count_data[ ,3:ncol(normalized_count_data)])


heatmap_matrix_intron <- normalized_count_data_introns[ ,3:ncol(normalized_count_data_introns)]
rownames(heatmap_matrix_intron) <- normalized_count_data_introns$ensemble_gene_id
colnames <- colnames(normalized_count_data_introns[ ,3:ncol(normalized_count_data_introns)])
```

First, we will create a heat map matrix
```{r heatmap}
# get_heatmap <- function(df) {
#   heatmap_matrix <- df[ ,3:ncol(df)]
#   rownames(heatmap_matrix) <- df$ensemble_gene_id
#   colnames <- colnames(df[ ,3:ncol(df)])  
#   if(min(heatmap_matrix) == 0){
#       heatmap_col = colorRamp2(c( 0, max(heatmap_matrix)), c( "white", "red"))
#     } else {
#       heatmap_col = colorRamp2(c(min(heatmap_matrix), 0, max(heatmap_matrix)), c("blue", "white", "red"))
#     }
#   current_heatmap <- ComplexHeatmap::Heatmap(as.matrix(heatmap_matrix),
#                                  show_row_dend = TRUE,
#                                  show_column_dend = TRUE, 
#                                  col=heatmap_col,
#                                  show_column_names = TRUE, 
#                                  show_row_names = FALSE,
#                                  show_heatmap_legend = TRUE
#                                  )
#   current_heatmap
# }
# get_heatmap(normalized_count_data_introns)
# get_heatmap(normalized_count_data_exons)

```
We cannot clearly see a difference in gene expression across the rows, because these data are not normalized for this conditions. So we will now re-create this heat map, normalizing the counts across the rows. 
```{r}
# get_heatmap_normalized <- function(df) {
#   heatmap_matrix <- df[ ,3:ncol(df)]
#   rownames(heatmap_matrix) <- df$ensemble_gene_id
#   colnames <- colnames(df[ ,3:ncol(df)])  
#   heatmap_matrix <- t(scale(t(heatmap_matrix)))
#   if(min(heatmap_matrix) == 0){
#       heatmap_col = colorRamp2(c( 0, max(heatmap_matrix)), c( "white", "red"))
#     } else {
#       heatmap_col = colorRamp2(c(min(heatmap_matrix), 0, max(heatmap_matrix)), c("blue", "white", "red"))
#     }
#   current_heatmap <- ComplexHeatmap::Heatmap(as.matrix(heatmap_matrix),
#                                  show_row_dend = TRUE,
#                                  show_column_dend = TRUE, 
#                                  col=heatmap_col,
#                                  show_column_names = TRUE, 
#                                  show_row_names = FALSE,
#                                  show_heatmap_legend = TRUE
#                                  )
#   current_heatmap
# }
# get_heatmap_normalized(normalized_count_data_introns)
# get_heatmap_normalized(normalized_count_data_exons)
```


```{r}
gene_of_interest <- which(normalized_count_data_introns$hgnc_symbol == "CLOCK")
participants <- c("Intron_15", "Intron_3", "Intron_2","Intron_6", "Intron_7", "Intron_9", "Intron_13", "Intron_4", "Intron_12", "Intron_1")
timepoint_clock_matrix <- matrix(nrow=10, ncol=0)
row.names(timepoint_clock_matrix) <- participants
create_timepoint_matrix <- function(grep_pattern, timepoint) {
  tp <- grep(colnames(normalized_count_data_introns),
                          pattern=grep_pattern)
  m <- (t(normalized_count_data_introns
                       [gene_of_interest, tp]))
  temp_rownames <- strsplit(rownames(m), " ")
  new_rownames <- lapply(temp_rownames, function(x) {
    new_name <- unlist(strsplit(x, "_"))[1:2]
    new_name <- paste(new_name[1], new_name[2], sep="_")
    return(new_name)
  })
  colnames(m) <- c(timepoint)
  row.names(m) <- new_rownames
  return(m)
}
t1 <- create_timepoint_matrix("Intron.*_12.00", "12.00")
t2 <- create_timepoint_matrix("Intron.*_16.00", "16.00")
t3 <- create_timepoint_matrix("Intron.*_20.00", "20.00")
t4 <- create_timepoint_matrix("Intron.*_00.00", "00.00")
t5 <- create_timepoint_matrix("Intron.*_04.00", "04.00")
t6 <- create_timepoint_matrix("Intron.*_08.00", "08.00")
matricies <- list(t1, t2, t3, t4, t5, t6)
for (l in matricies) {
  timepoint_clock_matrix <- cbind(timepoint_clock_matrix, l[, 1][match(rownames(timepoint_clock_matrix), rownames(l))])
}
colnames(timepoint_clock_matrix) <- c("12.00", "16.00", "20.00", "00.00", "04.00", "08.00")
timepoint_clock_matrix
```
To compare the CLOCK gene across our timepoint groups, we will perform an ANOVA as we have more than 2 groups in the data.
```{r}
df_clock_timepoint <- data.frame()
for (col in 1:ncol(timepoint_clock_matrix)) {
  values <- as.data.frame(timepoint_clock_matrix[col, ])
  timepoints <- rep(c(colnames(timepoint_clock_matrix)[col]), 6)
  values <- cbind(values, timepoints)
  colnames(values) <- c("values", "timepoints")
  rownames(values) <- NULL
  df_clock_timepoint <- rbind(df_clock_timepoint, values)
}
df_clock_timepoint[1:5, ]
aov_clock <- aov(df_clock_timepoint$values ~ df_clock_timepoint$timepoints)
summary(aov_clock)
```
Our P value is >0.05, hence we equal variance between the timepoints. 
```{r}
gene_of_interest <- which(normalized_count_data_introns$hgnc_symbol == "CLOCK")


```

Here we revisit the MDS plot developed in A1, but using the limma package. Again, we notice For the most part, samples in the intron and exon class cluster together with some outliers away from the 2 main clustering sites. 
```{r}
pat_colors <- rainbow(10)
pat_colors <- unlist(lapply(pat_colors,FUN=function(x){rep(x,2)}))
limma::plotMDS(heatmap_matrix_intron,
               col = pat_colors)
```

In the study related to the dataset, they are looking at which genes are expressed at the 6 different timepoints to get a sense of the genes involved in the human circadian rhythm. 

Here, we will fit our data from each time point to a linear model. To do this, we will first we will segegrate our patient samples intro groups by patient and timepoint of sample.

```{r}
samples <- data.frame(
        lapply(colnames(normalized_count_data_introns)[3:ncol(normalized_count_data_introns)], 
        FUN=function(x){
          unlist(strsplit(x, split = "_"))[c(2,4)]}))
colnames(samples) <- colnames(normalized_count_data_introns)[3:ncol(normalized_count_data_introns)]
rownames(samples) <- c("patient","timepoint")
samples <- data.frame(t(samples))
samples[1:5, ]

```
We will now create our model design. 
```{r}
model_design <- model.matrix(~ samples$timepoint)
model_design[1:5, 1:6]
```
Now we will our create our data matrix to apply the model to:
```{r}
expressionMatrix <- as.matrix(normalized_count_data_introns[,3:ncol(normalized_count_data_introns)])
rownames(expressionMatrix) <- normalized_count_data_introns$ensembl_gene_id
colnames(expressionMatrix) <- colnames(normalized_count_data_introns)[3:ncol(normalized_count_data_introns)]
minimalSet <- ExpressionSet(assayData=expressionMatrix)
fit <- lmFit(minimalSet, model_design)
fit2 <- eBayes(fit, trend=TRUE)
topfit <- topTable(fit2, 
                   coef=ncol(model_design),
                   adjust.method = "BH",
                   number = nrow(expressionMatrix))
#merge hgnc names to topfit table
output_hits <- merge(normalized_count_data_introns[,1:2],
                     topfit,
                     by.y=0,by.x=1,
                     all.y=TRUE)
#sort by pvalue
output_hits <- output_hits[order(output_hits$P.Value),]

output_hits[1:5, ]

genes_pass <- length(which(output_hits$P.Value < 0.05))
genes_pass_correction <- length(which(output_hits$adj.P.Val < 0.05))
```
We have `r genes_pass` genes that pass the p-value threshold of <0.05.
Further, we have `r genes_pass_correction` genes that pass the corrected P value threshold. 

We have a sizeable amount of genes that pass the p-value threshold of 0.05, so we will represent these genes that passed through a heatmap. 
```{r}
heatmap_matrix_new <- normalized_count_data_introns[,3:ncol(normalized_count_data_introns)]
rownames(heatmap_matrix_new) <- normalized_count_data_introns$ensembl_gene_id
colnames(heatmap_matrix_new) <- colnames(normalized_count_data_introns[,3:ncol(normalized_count_data_introns)])
heatmap_matrix_new <- t(scale(t(heatmap_matrix_new)))

top_hits <- output_hits$ensembl_gene_id[output_hits$P.Value<0.05]
heatmap_matrix_tophits <- t(
  scale(t(heatmap_matrix_new[
    which(rownames(heatmap_matrix_new) %in% top_hits),])))


if(min(heatmap_matrix_tophits) == 0){
    heatmap_col = circlize::colorRamp2(c( 0, max(heatmap_matrix_tophits)), 
                             c( "white", "red"))
  } else {
    heatmap_col = circlize::colorRamp2(c(min(heatmap_matrix_tophits), 0, max(heatmap_matrix_tophits)), c("blue", "white", "red"))
  }
current_heatmap <- ComplexHeatmap::Heatmap(as.matrix(heatmap_matrix_tophits),
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                               show_row_dend = TRUE,
                               show_column_dend = FALSE, 
                               show_column_names = TRUE, 
                               show_row_names = FALSE,
                               show_heatmap_legend = TRUE,
                           column_title =  "Heatmap of top gene hits - Limma Model",
                                                       column_names_gp = gpar(fontsize = 8)

                               )
current_heatmap
```
INSERT ANALYSIS OF HEATMAP HERE.

Now we will continue our differential analysis to see differential expression using a different model, the Quasi liklihood model. \
\
First we will get our filtered count data from A1 and create our Quasi liklihood model. 
ASK HERE WHAT COEF TO CHOOSE WITH MULTIPLE GROUPS...
```{r}
intron_data_matrix <- inverse_data_matrix[ , grepl("Intron.*", colnames(inverse_data_matrix))]
d = DGEList(counts=intron_data_matrix, group=samples$timepoint)
d <- estimateDisp(d, model_design)
fit <- glmQLFit(d, model_design)
model_design[1:10, 1:5]
qlf.pos_vs_neg <- glmQLFTest(fit)
topTags(qlf.pos_vs_neg)
```
```{r}
qlf_output_hits <- topTags(qlf.pos_vs_neg,sort.by = "PValue",
                           n = nrow(normalized_count_data))
quasi_pvalue_pass <- length(which(qlf_output_hits$table$PValue < 0.05))
quasi_corrected_pass <- length(which(qlf_output_hits$table$FDR < 0.05))

```
With the Quasi-liklihood model, `r quasi_pvalue_pass` genes pass the threshold p-value <0.05 and `r quasi_corrected_pass` pass the correction.\
\
Next we will compare the different models we generated (Limma vs Quasi liklihood)
```{r}
qlf_pat_model_pvalues <- data.frame(
          ensembl_id = rownames(qlf_output_hits$table),
          qlf_patient_pvalue=qlf_output_hits$table$PValue)
limma_pat_model_pvalues <-  data.frame(
          ensembl_id = output_hits$ensembl_gene_id,
          limma_patient_pvalue = output_hits$P.Value)
two_models_pvalues <- merge(qlf_pat_model_pvalues,
                            limma_pat_model_pvalues,
                            by.x=1,by.y=1)
two_models_pvalues$colour <- "black"
two_models_pvalues$colour[two_models_pvalues$qlf_patient_pvalue<0.05] <- "orange"
two_models_pvalues$colour[two_models_pvalues$limma_patient_pvalue<0.05] <- "blue"
two_models_pvalues$colour[two_models_pvalues$qlf_patient_pvalue<0.05 & two_models_pvalues$limma_patient_pvalue<0.05] <- "red"
plot(two_models_pvalues$qlf_patient_pvalue,
     two_models_pvalues$limma_patient_pvalue,
     col = two_models_pvalues$colour,
     xlab = "QLF patient model p-values",
     ylab ="Limma Patient model p-values",
     main="QLF vs Limma")

```
```{r}
ensembl_of_interest <- normalized_count_data_introns$ensembl_gene_id[
  which(normalized_count_data_introns$hgnc_symbol == "CLOCK")]
two_models_pvalues$colour <- "grey"
two_models_pvalues$colour[two_models_pvalues$ensembl_id==ensembl_of_interest] <- "red"
plot(two_models_pvalues$qlf_patient_pvalue,
     two_models_pvalues$limma_patient_pvalue,
     col = two_models_pvalues$colour,
     xlab = "QLF patient model p-values",
     ylab ="Limma Patient model p-values",
     main="QLF vs Limma")
points(two_models_pvalues[
  two_models_pvalues$ensembl_id==ensembl_of_interest,2:3],
       pch=24,  col="red", cex=1.5)
```

Now we will generate a heatmap for the Quasi Likelihood model. 
```{r}
top_hits <- rownames(qlf_output_hits$table)[output_hits$P.Value<0.05]
heatmap_matrix_tophits <- t(
  scale(t(heatmap_matrix_new[which(rownames(heatmap_matrix_new) %in% top_hits),])))
if(min(heatmap_matrix_tophits) == 0){
    heatmap_col = circlize::colorRamp2(c( 0, max(heatmap_matrix_tophits)), 
                             c( "white", "red"))
  } else {
    heatmap_col = circlize::colorRamp2(c(min(heatmap_matrix_tophits), 0, max(heatmap_matrix_tophits)), c("blue", "white", "red"))
  }
current_heatmap <- ComplexHeatmap::Heatmap(as.matrix(heatmap_matrix_tophits),
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                               show_row_dend = TRUE,
                               show_column_dend = TRUE, 
                               col=heatmap_col,
                               show_column_names = TRUE, 
                               show_row_names = FALSE,
                               show_heatmap_legend = TRUE,
                               column_title =  "Heatmap of top gene hits - Quasi liklihood Model", 
                            column_names_gp = gpar(fontsize = 8)
)
current_heatmap
```
Compared to the limma heatmap, we see signficantly less differentiation here. However, the pattern of more differentation at timepoints 00:00 and 04:00 (times where participants are likely asleep) remains consistent between the two models.

## Thresholded List
```{r}
qlf_output_hits_withgn <- merge(normalized_count_data[,1:2],qlf_output_hits, by.x=1, by.y = 0)
qlf_output_hits_withgn[,"rank"] <- -log(qlf_output_hits_withgn$PValue,base =10) * sign(qlf_output_hits_withgn$logFC)
qlf_output_hits_withgn <- qlf_output_hits_withgn[order(qlf_output_hits_withgn$rank),]

upregulated_genes <- qlf_output_hits_withgn$hgnc_symbol[
  which(qlf_output_hits_withgn$PValue < 0.40 
             & qlf_output_hits_withgn$logFC > 0)]
downregulated_genes <- qlf_output_hits_withgn$hgnc_symbol[
  which(qlf_output_hits_withgn$PValue < 0.05 
             & qlf_output_hits_withgn$logFC < 0)]

n_upreg_genes <- length(upregulated_genes)
n_downreg_genes <- length(downregulated_genes)


write.table(x=upregulated_genes,
            file=file.path("data","upregulated_genes.txt"),sep = "\t",
            row.names = FALSE,col.names = FALSE,quote = FALSE)
write.table(x=downregulated_genes,
            file=file.path("data","downregulated_genes.txt"),sep = "\t",
            row.names = FALSE,col.names = FALSE,quote = FALSE)

```
We have identified `r {n_upreg_genes}` upregulated genes and `r {n_downreg_genes}` downregulated genes to be used in our gene enrichment analysis. 

## Enrichment Analysis
```{r}

gostres <- gprofiler2::gorth(upregulated_genes, source_organism = "hsapiens",
  target_organism = "hsapiens", numeric_ns = "", mthreshold = Inf,
  filter_na = TRUE)

gprofiler2::gostplot(gostres)

```

## Questions
1. Which method did you choose and why?
2. What annotation data did you use and why? What version of the annotation are you using?
3. How many genesets were returned with what thresholds?
4. Run the analysis using the up-regulated set of genes, and the down-regulated set of genes separately. How do these results compare to using the whole list (i.e all differentially expressed genes 5. together vs. the up-regulated and down regulated differentially expressed genes separately)?
6. Do the over-representation results support conclusions or mechanism discussed in the original paper?
7. Can you find evidence, i.e. publications, to support some of the results that you see. How does this evidence support your results.
## References
[1] L. Perrin et al., “Transcriptomic analyses reveal rhythmic and CLOCK-driven pathways in human skeletal muscle,” eLife, vol. 7, p. e34114, Apr. 2018, doi: 10.7554/eLife.34114.
